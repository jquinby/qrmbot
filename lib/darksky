#!/usr/bin/perl
# DarkSky API client -- current conditions.  2-clause BSD license.

# Substantially hustled from the qrm's original wx script which is
# Copyright 2018 /u/molo1134. All rights reserved.

# requires an API key from DarkSky.com  Place into the file $HOME/.darksky as follows:
#
# $apikey = "0123456789abcdef";
#
# The current conditions object ("currently") returns data as follows:
# {
#  "time": 1556741044,
#  "summary": "Mostly Cloudy",
#  "icon": "partly-cloudy-day",
#  "nearestStormDistance": 12,
#  "nearestStormBearing": 195,
#  "precipIntensity": 0,
#  "precipProbability": 0,
#  "temperature": 84.35,
#  "apparentTemperature": 85.93,
#  "dewPoint": 64.51,
#  "humidity": 0.52,
#  "pressure": 1008.38,
#  "windSpeed": 7.95,
#  "windGust": 8.71,
#  "windBearing": 139,
#  "cloudCover": 0.8,
#  "uvIndex": 5,
#  "visibility": 9.27,
#  "ozone": 320.06
#}

use strict;
use utf8;
use feature 'unicode_strings';
binmode(STDOUT, ":utf8");

our $apikey = undef;

my $apikeyfile = $ENV{'HOME'} . "/.darksky";
if (-e ($apikeyfile)) {
  require($apikeyfile);
} else {
  die "error: unable to read file $apikeyfile"
}
die "error: no API key set" unless defined($apikey);

my $url = "https://api.darksky.net/forecast/$apikey/$ARGV[0]?units=auto&exclude=hourly,minutely";

# darksky returns US Imperial units by default, but the units can be tweaked via
# the query parameter 'units' as seen above. Their docs spell out the following
# options:
#
# auto: automatically select units based on geographic location
# ca: same as si, except that windSpeed and windGust are in kilometers per hour
# uk2: same as si, except that nearestStormDistance and visibility are in miles, and windSpeed and windGust in miles per hour
# us: Imperial units (the default)
# si: SI units
#
# as it happens, the .flags.units object will return the units used in the
# data. 
#
# The 'exclude' block just does that - reduce the size of the response a bit
# since we don't need data that granular.

my %results;
my $rec_ref;
my %rec;
my $units;
my $forecast;

open(HTTP, '-|', "curl -s -L --insecure '$url' | jq -r '.daily.summary,.currently,.flags.units'");
binmode(HTTP, ":utf8");
while (<HTTP>) {
    chomp;

    $forecast = $_ if ($. == 1);

    if (/"(\w+)":\s*"?(.*?)"?,?\s*$/) {
        my ($key, $value) = ($1, $2);
        $results{$key} = $value;
        #print "$key -> $value\n";
    }

    $units = $_ if eof;
}
close(HTTP);

for ($units){

    if (/us/) {

        print "Temp: " . sprintf("%1d",$results{temperature}) . "°F ";
        print "Feels like: " .sprintf("%1d",$results{apparentTemperature}) . "°F ";
        print "Humidity: " . sprintf("%.1f%%",100 * $results{humidity}) . " ";
        print "Barometer: " . sprintf("%2d",$results{pressure}) . "mb ";
        print "Visibility: " . sprintf("%1d",$results{visibility}) . " miles ";
        print "with " . sprintf(100 * $results{cloudCover}) . "% cloud cover. \n";
        print "Dew point: " . sprintf("%1d",$results{dewPoint}) . "°F ";
        print "Nearest storm is ". sprintf("%1d",$results{nearestStormDistance}) . " miles away, bearing " . $results{nearestStormBearing} . "° ";
        print "Wind: " . sprintf("%1d",$results{windSpeed}) . " mph, direction: " . $results{windBearing} . "° \n";
        print "Forecast: " . $forecast;
    }

    # everyone else gets SI/metric 

    else {

        print "Temp: " . sprintf("%1d",$results{temperature}) . "°C ";
        print "Feels like: " .sprintf("%1d",$results{apparentTemperature}) . "°C ";
        print "Humidity: " . sprintf("%.1f%%",100 * $results{humidity}) . " ";
        print "Barometer: " . sprintf("%2d",$results{pressure}) . "hPa \n";
        print "Visibility: " . sprintf("%1d",$results{visibility}) . "km ";
        print "with " . sprintf(100 * $results{cloudCover}) . "% cloud cover. ";
        print "Dew point: " . sprintf("%1d",$results{dewPoint}) . "°C ";
        print "Nearest storm is ". sprintf("%1d",$results{nearestStormDistance}) . "km away, bearing " . $results{nearestStormBearing} . "° ";
        print "Wind: " . sprintf("%1d",$results{windSpeed}) . " km/h, direction: " . $results{windBearing} . "° \n";
        print "Forecast: " . $forecast;
    }
}
exit 0;
